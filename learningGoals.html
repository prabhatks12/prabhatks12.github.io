<!DOCTYPE html>
<html>
<head>
	<title>Portfolio</title>
	<link rel="stylesheet" type="text/css" href="css/style.css">
	<meta name="viewport" content="width=device-width, initial-scale=0.7">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
</head>


<body>

<div class="col-12 row">

	<div class="col-1"> </div>

	<div class="col-10">
		<p class="heading_text"> Learning Goals </p>
		These are the topics which I have to revise to have good base.
		<br><br>

		<h5>Machine Learning Algorithm</h5>
		<br>
		<table>
		    <tr> <th>Sl No</th> <th>Topic</th> <th>Book/ Link </th> <td>Implementation</td> </tr>
		    <tr> <td>1</td> <td>Desion Tree</td> <td>Some Link </td> <td> Some link</td> </tr>
		</table>

		<br><br>
		<h5>General Alogrithms</h5>
		<br>
		<table>
			<tr> <th>Sl No</th> <th>Topic</th> <th>Book/ Link </th> <th>Implementation</th> </tr>

		</table>

		<br><br>


		<!-- ================================   AI Algorthim section =============================== -->

		<h5>Artificial Intellegence Algorithm</h5>
		<br>

		<table>

			<!-- headers -->
		    <tr> <th>Sl No</th> <th>Topic</th> <th>Explanation </th> <th>Implementation</th> <th>Notes</th> </tr>
			<tr> <td colspan="5"> <b>Un-Informed search Strategy</b> (from AI Book 1 Ch 3)</td></tr>

			<!-- 1 -->
			<tr> <td> 1 </td> <td> <b> BFS DFS </b> : Short implementation </td>
				 <td> Geeks for Geeks <a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/"> BFS </a> and <a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/"> DFS </a></td>
				 <td> <a href="algorithms/basicAlgorithms/BfsDfs_Basic.txt"> Present in Algorithms Folder </a></td>
				 <td> Good for leanring Adjacency List</td>
			</tr>

			<!-- 2 -->
			<tr> <td> 2 </td> <td> <b>Uniform Cost Search </b> or Cheapest First Search </td>
				 <td> Explanation: <a href="https://www.youtube.com/watch?v=dRMvK76xQJI&ab_channel=JohnLevine"> YouTube JohnLevine </a></td>
				 <td> Read algorithm from the AI Book 1 , also take reference from <a href="https://www.geeksforgeeks.org/uniform-cost-search-dijkstra-for-large-graphs/"> Geeks for geeks</a></td>
				 <td> It is a variant of Dijsktra Algorithm & it uses priority queue</td>
			</tr>

			<!-- 3 -->
			<tr> <td> 3 </td> <td> <b>Depth Limited Search and Itertive Deepening Search </b>(or Iterative Deepening Depth First Search)</td>
				 <td> Explanation: Read algorithm from the AI Book 1 for both , <a href="https://www.youtube.com/watch?v=Y85ECk_H3h4&ab_channel=JohnLevine">Youtube JohnLevine</a></td>
				 <td>  Itertive Deepening Search <a href="https://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/"> Geeks for geeks</a></td>
				 <td> Depth limited search works same as dfs with an additional parameter to check depth.
					  Itertive deepening uses a loop to increment this depth.</td>
			</tr>

			<!-- 4 -->
			<tr> <td> 4 </td> <td> <b>Bi-Directional Search </b> </td>
				 <td> Explanation: read from  AI Book 1 </a></td>
				 <td> Take reference from <a href="https://www.geeksforgeeks.org/bidirectional-search/"> Geeks for geeks</a></td>
				 <td> The majaor change is in adding the node to Adjacency List, add the node in both order <br> void Graph::addEdge(int u, int v){ <br>  this->adj[u].push_back(v); <br> this->adj[v].push_back(u); };<br></td>
			</tr>


			<tr> <td colspan="5"> <b>Informed search Strategy </b>(using Heuristic , from AI Book 1 Ch 3) </td> </tr>

			<!-- 5 -->
			<tr>
				<td>5</td> <td> <b>A star </b></td>
				<td> <a href="https://www.youtube.com/watch?v=6TsL96NAZCo&ab_channel=JohnLevine">Best Explanation by JohnLevine, </a> good explanation from <a href="https://www.youtube.com/watch?v=amlkE0g-YFU&ab_channel=edureka%21"> Edureka video: </a> Watch till explanation </td>
				<td> <a href=" https://www.annytab.com/a-star-search-algorithm-in-python/"> Best Implementation : </a> See the working code</td>
				<td> f(n) = g(n) + h(n)  --> g(n) added cost to from the start to current node, h(n) --> approx cost to the end node from the current node,
					thus uses earned knowledge. Also check under-estimation and over-estimation based on heuristic values(needed for optimal sol) </td>
			</tr>

			<!-- 6 -->
			<tr>
				<td>6</td> <td><b>Best First Search</b> or (Greedy Best first search)</td>
				<td> <a href="https://www.youtube.com/watch?v=O9Bp5O2aeu0&ab_channel=5MinutesEngineering"> Youtube: 5 minutes Enginnering </a> </td>
				<td> Book : page 99  and class notes pg 49, lecture 2 pdf, <b>heuristic are not optimal </b></td>
				<td>Greedy best-first search tries to expand the node that is closest to the goal, on the grounds that this is likely to lead to a solution quickly.
					Thus, it evaluates nodes by using just the heuristic function; that is, f(n)=h(n). It is not using the prior costs which lead it to the current node (g(n)).
					Greedy BFS can get trapped in infinte loop, it doesnt have any visited list.
				</td>
			</tr>

			<tr> <td colspan="5"> <b>Adverserial search Strategy </b>(from AI Book 1 Ch 5) </td> </tr>

			<!-- 7 -->
			<tr>
				<td>7</td> <td> <b>MiniMax and Alpha Beta Pruining </b></td>
				<td> <a href="https://www.youtube.com/watch?v=l-hh51ncgDI&ab_channel=SebastianLague">Best Explanation by Sebastian Lague</a></td>
				<td> Best Implementation : see the video mentioned, read book ch 5</td>
				<td> Alpha Beta Pruining are based on minimax, the algorithms are almost similar, easy to understand.
					 These are used for turnwise multiplayer games like chess. <b>Try implementing it on a game</b></td>
			</tr>


			<!-- 8 -->
			<tr>
				<td>8</td> <td> <b>Expectimax Algorithm </b></td>
				<td> See tutorial notes for week4, also see book Ai, ch 5 page 178</td>
				<td> Almost same as minimax, <a href="https://www.geeksforgeeks.org/expectimax-algorithm-in-game-theory/">Geeks for geeks</a></td>
				<td>Take average on from minium nodes. It is like risk taking for getting higher positive outcomes.<b>Try implementing it on a game</b></td>
			</tr>

			<tr> <td colspan="5"> <b>Knowledge Representation and Propositional Logic </b>( not really fond of this part, for the syllabus sake, do from videos) </td> </tr>

			<!-- 9 -->
			<tr>
				<td>9</td> <td> <b>Propositional Logic </b></td>
				<td> <a href="https://www.youtube.com/watch?v=6490tKrGEic&ab_channel=GateSmashers">Gate Smashers</td>
				<td> No implemenation, see notes <a href="https://www.javatpoint.com/propositional-logic-in-artificial-intelligence">Java T point</a></td>
				<td>See videos instead of book, book is too lengthy. Syntax, sementics also defined here</td>
			</tr>

			<!-- 10 -->
			<tr>
				<td>10</td> <td> <b>Knowledge Representation </b></td>
				<td> <a href="https://www.youtube.com/watch?v=9iN3O_oL2ac&ab_channel=GateSmashers">Gate Smashers</td>
				<td> No implemenation, see notes <a href="https://www.javatpoint.com/knowledge-representation-in-ai">Java T point</a></td>
				<td>Types of knowledge</td>
			</tr>
		</table>
		<br><br>

	<!-- ================================ Analysis of Algorthim section =============================== -->


	<h5>Analysis of Algorthim or General Algorithms</h5>
		<br>

		<table>

			<!-- headers -->
		    <tr> <th>Sl No</th> <th>Topic</th> <th>Explanation </th> <th>Implementation</th> <th>Notes</th> </tr>
			<tr> <td colspan="5"> <b>Greedy Technique </b> (from Algorithm Book 1 Ch 9)</td></tr>

			<!-- 1 -->
			<tr> <td> 1 </td> <td> <b> Prims Algorithm </b> Spanning tree</td>
				 <td> Geeks for Geeks <a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/"> Prims </a> , rest read from the course videos</td>
				 <td> Read from the book </td>
				 <td>Spanning Tree: contains all vertex but not all edges <a href="https://www.tutorialspoint.com/data_structures_algorithms/spanning_tree.htm"> Spanning Link</a></td>
			</tr>
			
			<!-- 2 -->
			<tr> <td> 2 </td> <td> <b> Kruskal Algorithm </b> Spanning tree</td>
				 <td> Geeks for Geeks <a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/"> Kruskal </a>
				 ,rest read from the course videos </td>
				 <td> Read from the book </td>
				 <td>Spanning Tree: contains all vertex but not all edges <a href="https://www.tutorialspoint.com/data_structures_algorithms/spanning_tree.htm"> Spanning Link</a></td>
			</tr>
			
			<tr> <td colspan="5"> <b>Dynamic Programming</b> (from Algorithm Book 1 Ch 8)

				<br>
				<b>Idea:</b> We want to solve problem by reusing previously solved sub-problems, we might use more than once the solved stored solution. In divide and conquer, sub solutions might be independent, sub problems might be dependent in dyanmic programming. Two types, top down and bottom up.			
				</td></tr>

				<!-- 2 -->
				<tr> <td> 1 </td> <td> <b> Coin row problem </b></td>
					 <td> Watch course video<a href="https://www.basicsbehind.com/2014/08/15/dynamic-programming/">Explanation and implementation</a></td>
					 <td> Read from the book page: 285</td>
					 <td> Course video is the best to understand, no need to code, basic lgorithm. <b>Note: </b>Learn how to back track</td>
				</tr>
			

				<!-- 2 -->
				<tr> <td> 2 </td> <td> <b> Transitive closure on Warshall's Algorithm </b></td>
					 <td> Watch course video (best explanation) <a href="https://www.geeksforgeeks.org/transitive-closure-of-a-graph/">Explanation and implementation</a></td>
					 <td> Read from the book page: 305</td>
					 <td> See implementation, easy to understand, bit difficult to implement</td>
				</tr>


				<!-- 2 -->
				<tr> <td> 3 </td> <td> <b> Edit Distance </b></td>
					 <td> Watch course video (best explanation) <a href="https://www.geeksforgeeks.org/edit-distance-dp-5/">Explanation and implementation Geeks</a>
					 <a href="https://youtu.be/We3YDTzNXEk">, Youtube implementation</a></td>
					 <td> Geeks implementation see</td>
					 <td> Important for knowing how many changes required to make 2 string equal. <b>Note: </b> See how to back track</td>
				</tr>

				<!-- 2 -->
				<tr> <td> 4 </td> <td> <b> Knap Sack </b></td>
					 <td> See from course video, and <a href="https://www.youtube.com/watch?v=nLmhmB6NzcM&ab_channel=AbdulBari">youtube AbdulBari</a></td>
					 <td> See book page 292, <br> We are calulating for a range of capacity values, handy if you need the result for the same set and for a value in this range.</td>
					 <td> <b>Equation based</b> 
					 	<br> V[i, j] = (max(V[i − 1, j], vi + V[i − 1, j − wi]) if j − wi ≥ 0, <br>V[i − 1, j] if j − wi < 0.  <br> V[0, j] = 0 for j ≥ 0 and V[i, 0] = 0 for i ≥ 0.	 
					</td>
				</tr>

				
			
		</table>


	<br><br>	





	</div>

	<div class="col-1"> </div>

</div>



<div class="col-12 row">

	<div class="col-1"> </div>

	<div class="col-10">

		<br><h3>Books reference </h3>
		1 : AI Book 1 : Artificial Intelligence , A Modern Approach , Third Edition , Stuart J. Russell and Peter Norvig<br>



		<br><h3>Extra resources </h3>
		For AI theory part, see <a href="https://www.javatpoint.com/artificial-intelligence-tutorial">Java T point notes, level: Basic </a><br>


		predicates
		<br><h3>Todo </h3>
		1. <a href="https://lti-adx.adelaide.edu.au/data/snake/">Create snake game using this logic </a> , and try to implement the algorithms <br>
		2. Add 2 more columns for complexity and wheter u have implemented it or not

		<br><br>

	</div>

	<div class="col-1"> </div>

</div>

</body>
</html>
